{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf600
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;\f1\fnil\fcharset0 HelveticaNeue-Bold;\f2\fnil\fcharset0 Menlo-Bold;
\f3\fnil\fcharset0 Menlo-Regular;\f4\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red29\green38\blue42;\red255\green255\blue255;\red245\green247\blue249;
\red29\green38\blue42;}
{\*\expandedcolortbl;;\cssrgb\c14902\c19608\c21961;\cssrgb\c100000\c100000\c100000;\cssrgb\c96863\c97647\c98039;
\cssrgb\c14902\c19608\c21961;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl340\sa280\partightenfactor0

\f0\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 You are given two\'a0
\f1\b non-empty
\f0\b0 \'a0linked lists representing two non-negative integers. The digits are stored in\'a0
\f1\b reverse order
\f0\b0 \'a0and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\
You may assume the two numbers do not contain any leading zero, except the number 0 itself.\

\f1\b Example:
\f0\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f2\b\fs26 \cf2 \cb4 Input:
\f3\b0  (2 -> 4 -> 3) + (5 -> 6 -> 4)\

\f2\b Output:
\f3\b0  7 -> 0 -> 8\

\f2\b Explanation:
\f3\b0  342 + 465 = 807.\
\pard\pardeftab720\sl340\sa280\partightenfactor0

\f4\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardeftab720\pardirnatural\partightenfactor0
\cf0 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97***********\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
/**\
 * Definition for singly-linked list.\
 * public class ListNode \{\
 *     int val;\
 *     ListNode next;\
 *     ListNode(int x) \{ val = x; \}\
 * \}\
 */\
class Solution \{\
   int[] a=new int[100];\
    int[] b=new int[100];\
    \
    \
    int i,j,rem=0,index,check;\
    ListNode temp,res;\
    \
    public int find_numa(ListNode l,int k)\
    \{\
         while(l!=null)\
         \{       a[++k]=l.val;\
                l=l.next;\
         \}\
        return k;\
    \}\
    \
    public int find_numb(ListNode l,int k)\
    \{\
         while(l!=null)\
         \{       b[++k]=l.val;\
                l=l.next;\
         \}\
        return k;\
    \}\
    \
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) \{\
        \
        for(int i=0;i<100;i++)\
         a[i]=b[i]=0;\
        \
        i=find_numa(l1,0);\
        \
        j=find_numb(l2,0);\
        \
        \
        if(j>=i)\
        \{index=j;\}\
        else \
        \{index=i;\}\
        \
       \
        \
        \
        for(i=1;i<=index;i++)\
        \{\
         rem=a[i]+b[i]+(rem/10);\
\
            if(temp==null)\
        \{   res=new ListNode(rem%10);  \
            temp=res;\
        \}\
        else\{\
        res.next=new ListNode(rem%10);\
        res=res.next;\
        \}\
            \
        \
        \}\
        \
        if(i>index && (rem/10)!=0)\
        \{  res.next=new ListNode(rem/10);  \
            res=res.next;\
        \}\
        \
        \
                       \
        return temp;\
    \}\
   \
    \
\}}