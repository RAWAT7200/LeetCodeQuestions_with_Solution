{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf600
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;\f1\fnil\fcharset0 HelveticaNeue-Bold;\f2\fnil\fcharset0 Menlo-Regular;
\f3\fnil\fcharset0 Menlo-Bold;\f4\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red29\green38\blue42;\red255\green255\blue255;\red245\green247\blue249;
}
{\*\expandedcolortbl;;\cssrgb\c14902\c19608\c21961;\cssrgb\c100000\c100000\c100000;\cssrgb\c96863\c97647\c98039;
}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl340\sa280\partightenfactor0

\f0\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Given an array of integers, return\'a0
\f1\b indices
\f0\b0 \'a0of the two numbers such that they add up to a specific target.\
You may assume that each input would have\'a0
\i\b exactly
\i0\b0 \'a0one solution, and you may not use the\'a0
\i same
\i0 \'a0element twice.\

\f1\b Example:
\f0\b0 \
\pard\pardeftab720\sl400\partightenfactor0

\f2\fs26 \cf2 \cb4 Given nums = [2, 7, 11, 15], target = 9,\
\
Because nums[
\f3\b 0
\f2\b0 ] + nums[
\f3\b 1
\f2\b0 ] = 2 + 7 = 9,\
return [
\f3\b 0
\f2\b0 , 
\f3\b 1
\f2\b0 ].\
\pard\pardeftab720\sl340\sa280\partightenfactor0

\f0\fs28 \cf2 \cb3 \'a0
\f4\fs24 \cf0 \cb1 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97***********\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 class Solution \{\
public:\
    vector<int> twoSum(vector<int>& nums, int target) \{\
        \
        vector<int> res(2);\
        res[0]=-1;\
        res[1]=-1;\
    \
        unordered_map<int,int> mp(nums.size());\
        \
        for(int i=0;i<nums.size();i++)\
        \{\
            if(mp[target-nums[i]])\
            \{\
                res[0]=i;\
                res[1]=distance(nums.begin(),find(nums.begin(), nums.end(), target-nums[i]));\
                break;\
            \}\
            else\
               mp[nums[i]]++;\
         \
        \}\
        \
        sort(res.begin(),res.end());\
        \
        return res;\
    \}\
\};}